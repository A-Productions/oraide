#!/usr/bin/env bash

# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at http://mozilla.org/MPL/2.0/.

### Make a Language Server message given a path to a JSON file ###
#
# 0) Create the `ORALS` fifo from the `orals` directory (do this only 1 time!):
# $ mkfifo ORALS
#
# 1) Launch the `orals` executable from the `orals` directory:
# $ RUST_LOG=orals=trace cargo run --bin orals -- < ORALS
#
# 2) Invoke `mkmsg` (this script) from the `orals` directory:
# $ ./tools/mkmsg test_messages/hover.json > ORALS

### MAINTAINER TODOs ###
#
# - ingest json from stdin (user must `cat` if that's what they want)
#   which will let us use `jq`
#
###

has_jq= ; command -v jq >/dev/null 2>&1 && has_jq=true

# - read json file (file path given as 1st cli arg)
json_file_path="$1"
json_str="$(cat $json_file_path)"

# - optional: add the `jsonrpc` field to the json via `jq`
#       note: this is a "silent feature" that helps the user in the
#             event that they left `jsonrpc` out of their json file
[[ -n ${has_jq} ]] && json_str="$(jq '{"jsonrpc":"2.0"} + .' <<< "$json_str")"

# - optional: minify the json via `jq`
[[ -n ${has_jq} ]] && json_str="$(jq -c '.' <<< "$json_str")"

# - calc byte len of json str
json_str_byte_len=${#json_str}

# - create header str
header_str="content-length: ${json_str_byte_len}\r\n"

# - concat header + json body
message_str="${header_str}\r\n${json_str}"

# - write concat'd str to stdout
printf "$message_str"